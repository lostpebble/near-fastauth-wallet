#+title: Wallet Chain Key Rules

* Background

** Key Derivation

When signing using chain signatures each account has a unlimited number of keys. Each keys public key is derived from the account name and the key extension which is an arbitrary string. We can therefore describe a users keys as follow:

#+begin_src
"david.near,"              My key with no extension
"david.near, "             My key with an extension of " "
"david.near,cold_wallet"   My key with an extension of "cold_wallet"
#+end_src

If the keys aren't identical they have no relationship.

** Ambiguous Signatures

We're going to be potentially storing keys for users who hold assets on many chains. Different chains have different ways of serializing and signing transactions. Many chains take steps to ensure that their signatures are not valid signatures on other chains. EVM chains use "ChainID" to disambiguate signatures between different EVM chains. Dfinity uses a unique salt on the hash of the transaction.

Unfortunately, while this is a best practice, we can't guarantee that all chains do this (NEAR doesn't!). As such a user could receive an innocent looking transaction on one chain that can be used to take a destructive action on another chain. An apocryphal example is:

#+begin_src
Transaction: "7b73656e643a2022313030222c206e6f74652022227d"
Parsed SOL: claim free NFT
Parsed BTC: send 100 BTC to Attacker
#+end_src

The user would approve the SOL transaction but the attacker would also get the BTC transaction.

This can be solved by having a different keys for any chains that we can't prove could have ambiguous transactions. This means that while an attacker may create ambiguous transactions, it will only be for wallets without assets on the target chain.

* Aims

- To communicate how to parse & display a multichain transaction for informed user consent
- To minimize the number of times a user has to consent
- To ensure that a signature on one chain can't be used to take a meaningful action on another chain
- To allow applications to sometimes share keys

* Proposed Structure

** Structure

 #+begin_src
| account | chain | domain | subkey |
"david.near,bitcoin,near.org,somedata"
#+end_src

** Examples

#+begin_src
david.near,,,                  My personal untyped key, probably never used by a client
david.near,bitcoin,,           My personal bitcoin key
david.near,bitcoin,near.org,   A bitcoin key used on near.org
david.near,,near.org,          An untyped key used on near.org
#+end_src

* Example Flows

The following flows omit showing the cost of transaction fees. For those flows [[file:transaction_fees.org][see here]].

** Using a domains bitcoin key

An application at =near.org= wants to sign the Bitcoin transaction =Send 100 BTC= using the key =david.near,bitcoin,near.org,= .

#+begin_src
Signed ✅
#+end_src

We sign the transaction without confirmation because the key is owned by near.org.

** Using a personal Bitcoin key

An application at =near.org= wants to sign the Bitcoin transaction =Send 100 BTC= using the key =david.near,bitcoin,= .

#+begin_src
near.org would like to run the following Bitcoin transaction:

Send 100 BTC
[Accept] [Reject]
#+end_src

The user must make an informed decision about whether this is an action they would like to take.

#+begin_src
Signed ✅
#+end_src

** Using a personal EVM key to sign a Binance transaction
An application at =near.org= wants to sign the Binance Smart Chain transaction =Send 100 BNB, ChainID 56= using the key =david.near,evm,= . The wallet knows this is a BSC transaction because of the corresponding ChainID (56) and because the "evm" key is being used.

#+begin_src
near.org would like to run the following Binance Smart Chain transaction:

Send 100 BNB
[Accept] [Reject]
#+end_src

The user must make an informed decision about whether this is an action they would like to take.

#+begin_src
Signed ✅
#+end_src

** Using an untyped domain key

An application at =near.org= wants to sign the Bitcoin transaction =Send 100 BTC= using the key =david.near,,near.org,= .

#+begin_src
Signed ✅
#+end_src

While this is ill advised, it's still the domains key so the domain can still choose whether to sign something using it.

** Using another domains Bitcoin key

An application at =attacker.com= wants to sign the Bitcoin transaction =Send 100 BTC= using the key =david.near,bitcoin,near.org,= .

#+begin_src
Attacker.com would like to sign a transaction using your credentials from near.org

Send 100 BTC

This is a suspicious transaction and likely not one you should accept
[Reject] [Accept (Are you sure!)]
#+end_src

The user must make an explicit decision to do something that is ill advised.

#+begin_src
Signed ✅
#+end_src

The correct way for =attacker.com= to make this request is to somehow redirect the user to =near.org= and get the user to make a decision there.


* Design

Any key derivation format should have the following properties:

1. Canonical: for a given set of inputs the derivation path must always be the same or you'll get different keys.
2. Extensible: You can add new optional information without changing how old keys serialize.
3. Compact: otherwise it will increase the size of our transactions substantially.[fn:1]
4. Compatible: It must be easy to serialize from many languages

As such a few options have been considered.

** Borsh

[[https://borsh.io/][Borsh]] is our very own encoding format and it does 1,3 and 4 well, but it's not possible to add optional fields without changing the encoding format. Each non existent optional field is marked by a byte with a value of 0. This means that you don't need to know the type of an optional field up-front. This means:

#+begin_src rust
{
    a: A,
    b: Option<!>,
}
#+end_src

can be migrated to:

#+begin_src rust
{
    a: A,
    b: Option<B>,
}
#+end_src

Without any change to the encoding.

Therefore, if we were feeling like masochists, we could do the following version strategy:

#+begin_src rust
struct V1 {
    chain: Option<String>,
    domain: Option<String>,
    metadata: Option<[u8]>,
    v2: Option<!>
}

struct V2 {
    moon_phase: u8,
    // Change when we reach API version 3
    v3: Option<!>
}
#+end_src

Any compliant borsh implementation will serialize this correctly, effectively we're implementing protobuf in borsh.

** BIP-44

[[https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki][BIP-44]] is a key derivation format for cryptocurrencies which sounds perfect!

Briefly described it's:

#+begin_src
m / purpose': 44 / coin_type': SLIP-44 type / account':int / change: 0|1 / address_index:int
#+end_src

Unfortunately we use our key derivation for substantially different way to BIP-44 users.

1. We don't currently derive our key using BIP-33, so BIP-44 key paths won't make key derivation libraries work
2. We want to include domains in our key derivations, we could encode index in purpose, but we'd be off spec
3. The coin types make every chain have a different derivation path. We want to allow for sharing keys between EVM chain.

** Canonicalized Protobuf/Capnproto

These encoding formats have canonical formats, but actually encoding these is often not simple to support in different languages. It's also pretty easy to do this a bit wrong when you try to hand roll canonicalization yourself, which will lead to peoples assets ending up in a weird spot. Protobuf tooling also tends to be fairly heavyweight.

** Comma separated values

We initially used a version of comma separated values, which fits all the criteria, but every client language would have to implement it and many edge cases (data containing commas?) weren't covered in the spec. Fundamentally designing a brand new serialization format is normally a bad idea.

* Footnotes

[fn:1] This could perhaps be avoided by doing a hash of the derivation format.
